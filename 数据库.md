[TOC]

<div style="page-break-after: always;"></div>

# 第13节 UNION

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS computer_science;

CREATE TABLE computer_science(
    id int,
    name varchar(20)
);

INSERT INTO computer_science VALUES
(979489, "Terry"),
(102387, "Henry");

DROP TABLE IF EXISTS engineering;

CREATE TABLE engineering(
    id int,
    name varchar(20)
);

INSERT INTO engineering VALUES
(8347201, "Alice"),
(979489, "Terry");
```

---



**UNION**

`UNION`操作符用于合并两个或多个SELECT查询的结果集，`UNION`合并的结果集必须拥有相同的字段个数，且合并的字段类型必须兼容。

```mysql
SELECT [col] FROM [table_name1]
UNION
SELECT [col] FROM [table_name2];
```

`UNION`在合并两个结果集时，会默认去掉重复值，如果需要保留重复的记录就需要使用`UNION ALL`。

---

【代码】查询获取computer_science和engineering表中的所有学生

```mysql
SELECT id, name FROM computer_science
UNION
SELECT id, name FROM engineering;
```

> 运行结果

```
+---------+-------+
| id      | name  |
+---------+-------+
|  979489 | Terry |
|  102387 | Henry |
| 8347201 | Alice |
+---------+-------+
```

---

<div style="page-break-after: always;"></div>

# 第14节 date & time

**date & time**

`date`用于存储日期类数据，日期的有效值范围在`1000-01-01 ~ 9999-12-32`之间。

`time`用于存储时间类数据，时间的范围在`-838:59:59.000000 ~ 838:59:59.000000`之间，有效值在`00:00:00 ~ 23:59:59`之间。

`timestamp`用来存储时间戳数据，不仅可以保存日期数据，还可以保存时间数据。SQL中提供了`now()`用于生成当前时间戳。

SQL标准中时间和日期的数据类型主要包括`date`、`time`和`timestamp`，不过在不同数据库中会有所不同，如MySQL中还支持`datetime`来融合`date`和`time`；而在SQL Server中不支持`timestamp`类型，仅支持`datetime`类型。

---

【代码】创建exam日期表

```mysql
DROP TABLE IF EXISTS exam;

CREATE TABLE exam(
    course_name varchar(30),
    exam_date date,
    exam_time time
);

INSERT INTO exam VALUES
("Data Structure", "2021-09-13", "15:30:00"),
("Database", "2021-10-04", "10:20:00"),
("Software Engineering", "2021-09-14", "18:45:00");

SELECT * FROM exam;
```

> 运行结果

```
+----------------------+------------+-----------+
| course_name          | exam_date  | exam_time |
+----------------------+------------+-----------+
| Data Structure       | 2021-09-13 | 15:30:00  |
| Database             | 2021-10-04 | 10:20:00  |
| Software Engineering | 2021-09-14 | 18:45:00  |
+----------------------+------------+-----------+
```

---

<div style="page-break-after: always;"></div>

# 第15节 PRIMARY KEY & FOREIGN KEY

**PRIMARY KEY**

主键PRIMARY KEY是数据表中每条记录唯一的标识，每一张表都应有一个主键，主键只能有一个，且不能为空。

我们通常希望在每次插入新记录时，自动地创建主键字段的值。`AUTO_INCREMENT`关键字可以实现字段的自增，默认值为1，每条新记录递增1。不同的数据库对于自增的支持是不同的，有些数据库甚至不支持自增主键。

---

【代码】创建student_info表，设置id为主键，添加AUTO_INCREMENT约束

```mysql
DROP TABLE IF EXISTS student_info;

CREATE TABLE student_info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20)
);

DESC student_info;
```

> 运行结果

```
+------+-------------+-----+----+--------+---------------+
|Field |Type         |Null |Key |Default |Extra          |
+------+-------------+-----+----+--------+---------------+
|id    |int unsigned |NO   |PRI | NULL   |auto_increment |
|name  |varchar(20)  |YES  |    | NULL   |               |
+------+-------------+-----+----+--------+---------------+
```

---



**FOREIGN KEY**

对于关系数据库，最核心的东西莫过于`关系`二字。在开发中，表A的主键一般会作为表B的外键，用来表示表A与表B之间的关系。

外键`FOREIGN KEY`用来表示表与表之间的关系，一般使用另一张表的主键作为外键。

```mysql
FOREIGN KEY ([col1]) REFERENCES [table_name]([col2])
```

---

【代码】创建gpa_info表，设置student_id为外键，关键student_info表的id

```mysql
DROP TABLE IF EXISTS gpa_info;

CREATE TABLE gpa_info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    gpa double(5, 2),
    student_id int unsigned,
    FOREIGN KEY (student_id) REFERENCES student_info(id)
);

DESC gpa_info;
```

> 运行结果

```
+-----------+-------------+-----+----+--------+---------------+
|Field      |Type         |Null |Key |Default |Extra          |
+-----------+-------------+-----+----+--------+---------------+
|id         |int unsigned |NO   |PRI |NULL    |auto_increment |
|gpa        |double(5,2)  |YES  |    |NULL    |               |
|student_id |int unsigned |YES  |MUL |NULL    |               |
+-----------+-------------+-----+----+--------+---------------+
```

---

<div style="page-break-after: always;"></div>

# 第16节 JOIN

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS course;

CREATE TABLE course(
    id int PRIMARY KEY,
    name varchar(30)
);

INSERT INTO course VALUES
(1500, "Introduction to C"),
(2520, "Data Structure"),
(3110, "Operating System");

DROP TABLE IF EXISTS student;

CREATE TABLE student(
    id int PRIMARY KEY,
    name varchar(20),
    course_id int REFERENCES course(id)
);

INSERT INTO student VALUES
(979489, "Terry", 2520),
(102453, "Lily", 1500),
(919342, "Henry", 2520),
(235472, "Eric", NULL);
```

---



**JOIN**

`JOIN`语句用于将数据库中的两个或多个表组合起来，连接操作是关系数据库中体现“关系”的核心指令，常用于合并拥有关联关系的两表或者多表，并从中获取数据。

连接操作是使用外键最主要的方式，通过连接可以将两个或多个拥有外键关联的数据表的数据进行合并，然后选择需要的数据字段。

SQL有五种连接方式：

1. 交叉连接（`CROSS JOIN`）
2. 内连接（`INNER JOIN`）
3. 全外连接（`FULL OUTER JOIN`）
4. 左外连接（`LEFT OUTER JOIN`）
5. 右外连接（`RIGHT OUTER JOIN`）



**交叉连接**

交叉连接`CROSS JOIN`，又称笛卡尔连接（Cartesian Join），其作用是返回两表的笛卡尔积。

交叉连接可对任意两表进行连接，即使两表之间不存在关联关系。交叉连接就是将一张表的每一条记录与另一张表的每一条记录进行连接成为一条新记录，排列组合完毕后得到两张表的笛卡尔积。

---

【代码】获取student和course两表的笛卡尔积

```mysql
SELECT * FROM student CROSS JOIN course;
# 交叉连接还可以通过隐式的连接方式实现
# SELECT * FROM student, course;
```

> 运行结果

```
+--------+-------+-----------+------+-------------------+
| id     | name  | course_id | id   | name              |
+--------+-------+-----------+------+-------------------+
| 102453 | Lily  |      1500 | 3110 | Operating System  |
| 102453 | Lily  |      1500 | 2520 | Data Structure    |
| 102453 | Lily  |      1500 | 1500 | Introduction to C |
| 235472 | Eric  |      NULL | 3110 | Operating System  |
| 235472 | Eric  |      NULL | 2520 | Data Structure    |
| 235472 | Eric  |      NULL | 1500 | Introduction to C |
| 919342 | Henry |      2520 | 3110 | Operating System  |
| 919342 | Henry |      2520 | 2520 | Data Structure    |
| 919342 | Henry |      2520 | 1500 | Introduction to C |
| 979489 | Terry |      2520 | 3110 | Operating System  |
| 979489 | Terry |      2520 | 2520 | Data Structure    |
| 979489 | Terry |      2520 | 1500 | Introduction to C |
+--------+-------+-----------+------+-------------------+
```

---



**内连接**

内连接`INNER JOIN`是将一张表的每一条记录与另一张表的每一行记录进行比较，得到两张表匹配的记录集合。

![](./img/S16/1.png)

---

【代码】获取student和course两表的内连接集合

```mysql
SELECT * FROM student INNER JOIN course
ON student.course_id = course.id;

# 内连接是默认的连接方式，因此可以省略INNER关键字
# SELECT * FROM student JOIN course
# ON student.course_id = course.id;
```

> 运行结果

```
+--------+-------+-----------+------+-------------------+
| id     | name  | course_id | id   | name              |
+--------+-------+-----------+------+-------------------+
| 102453 | Lily  |      1500 | 1500 | Introduction to C |
| 919342 | Henry |      2520 | 2520 | Data Structure    |
| 979489 | Terry |      2520 | 2520 | Data Structure    |
+--------+-------+-----------+------+-------------------+
```

---



**左外连接**

若A和B两表进行左外连接，会在结果中包含左表（A）的所有记录，即使那些记录在右表（B） 没有符合连接条件相应的匹配记录，未匹配的记录会给予NULL填充。

![](./img/S16/2.png)

---

【代码】查询stundent表中每一个学生和该学生所选的课程

```mysql
SELECT student.name AS student_name, course.name AS course_name
FROM student LEFT OUTER JOIN course
ON student.course_id = course.id;
```

> 运行结果

```
+--------------+-------------------+
| student_name | course_name       |
+--------------+-------------------+
| Lily         | Introduction to C |
| Eric         | NULL              |
| Henry        | Data Structure    |
| Terry        | Data Structure    |
+--------------+-------------------+
```

---



**右外连接**

若A和B两表进行右外连接，会在结果中包含右表（ B）的所有记录，即使那些记录在左表（A）中没有符合连接条件相应的匹配记录，未匹配的记录会给予NULL填充。

![](./img/S16/3.png)

---

【代码】查询course表中每一门课和该课程下参与的学生

```mysql
SELECT course.name AS course_name, student.name AS student_name
FROM student RIGHT OUTER JOIN course
ON course.id = student.course_id;
```

> 运行结果

```
+-------------------+--------------+
| course_name       | student_name |
+-------------------+--------------+
| Introduction to C | Lily         |
| Data Structure    | Terry        |
| Data Structure    | Henry        |
| Operating System  | NULL         |
+-------------------+--------------+
```

---

`SQLite`是不支持右连接的，却可以通过更换保留表的位置用左连接来模拟右连接。



**全连接**

全连接是左、右外连接的并集，查询结果会包含被连接表的所有记录，若缺少匹配的记录，将以NULL填充。

![](./img/S16/4.png)

---

【代码】获取course和student两表的全连接

```sql
SELECT * FROM course FULL OUTER JOIN student
ON course.id = student.course_id;
```

---

一些数据库，比如MySQL是不支持全连接的，但可以通过左、右外连接的并集来模拟实现。

---

【代码】MySQL模拟实现全连接

```mysql
SELECT * FROM student LEFT JOIN course
ON course.id = student.course_id
UNION
SELECT * FROM student RIGHT JOIN course
ON course.id = student.course_id;
```

> 运行结果

```
+--------+-------+-----------+------+-------------------+
| id     | name  | course_id | id   | name              |
+--------+-------+-----------+------+-------------------+
| 102453 | Lily  |      1500 | 1500 | Introduction to C |
| 235472 | Eric  |      NULL | NULL | NULL              |
| 919342 | Henry |      2520 | 2520 | Data Structure    |
| 979489 | Terry |      2520 | 2520 | Data Structure    |
|   NULL | NULL  |      NULL | 3110 | Operating System  |
+--------+-------+-----------+------+-------------------+
```

---



**自连接**

自连接（self join）是一种特殊的连接方式，指的是与自身进行连接。自连接对于别名的要求是必须的，否则解析引擎无法判断出二者之间的关系。

---

【代码】查询employee表中薪资超期其领导的员工

```mysql
DROP DATABASE IF EXISTS employment;
CREATE DATABASE employment;
USE employment;

CREATE TABLE employee(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    salary decimal(8, 2),
    manager_id int unsigned
);

INSERT INTO employee VALUES
(1, "Terry", 9000, 3),
(2, "Eric", 8500, 4),
(3, "Henry", 8700, NULL),
(4, "Alice", 8900, NULL);

SELECT a.name
FROM employee AS a
JOIN employee AS b
ON a.manager_id = b.id
WHERE a.salary > b.salary;
```

> 运行结果

```
+-------+
| name  |
+-------+
| Terry |
+-------+
```

---

<div style="page-break-after: always;"></div>

# 第17节 GROUP BY & HAVING

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    age int unsigned CHECK(age > 0)
);

INSERT INTO info VALUES
(1, "Terry", 23),
(2, "Henry", 22),
(3, "Lily", 23),
(4, "Eric", 18);
```

---



**GROUP BY**

GROUP BY用于数据分组，一般与聚合函数一起使用。GROUP BY会根据数据字段来分组，并且根据给定的聚合函数对分组进行聚合操作。

```mysql
# [agg]表示聚合函数
SELECT [agg] FROM [table_name] GROUP BY [col];
```

---

【代码】将info表中的学生根据age进行分组，打印每个分组的学生数

```mysql
SELECT name, COUNT(*) FROM info GROUP BY age;
```

> 运行结果

```
+-------+----------+
| name  | COUNT(*) |
+-------+----------+
| Terry |        2 |
| Henry |        1 |
| Eric  |        1 |
+-------+----------+
```

---

MySQL中若出现`ERROR 1055 (42000)`错误，是因为默认开启了`ONLY_FULL_GROUP_BY`选项，需要将其关闭。

```mysql
set sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
```



**HAVING**

由于WHERE无法与聚合函数一起搭配使用，因此SQL增加`HAVING`指令。`HAVING`本身并无其他含义，它的主要功能是替代` WHERE`。

`HAVING`不能单独出现，必须与聚合函数搭配使用，且常与GROUP BY一起出现。

```mysql
SELECT [agg] FROM [table_name]
GROUP BY [col] HAVING [condition];
```

---

【代码】将info表中的学生根据age进行分组，打印大于20岁的每个分组人数

```mysql
SELECT age, COUNT(*) FROM info
GROUP BY age HAVING age > 20;
```

> 运行结果

```
+------+----------+
| age  | COUNT(*) |
+------+----------+
|   23 |        2 |
|   22 |        1 |
+------+----------+
```

---

<div style="page-break-after: always;"></div>

# 第18节 子查询

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2)
);

INSERT INTO info VALUES
(1, "Terry", 3.8),
(2, "Lily", 4.2),
(3, "Eric", 3.4),
(4, "Henry", 3.8);
```

---



**子查询**

子查询又称嵌套查询，是种嵌套在其它SQL查询的WHERE子句中的查询。SQL子查询是一种复杂的查询方式，一般子查询语句都可以被分为主查询部分和子查询部分。子查询部分为主查询部分服务，常用于为主查询返回其所需数据，或者进一步筛选主查询数据。

---

【代码】获取info表中小于gpa最高分的所有学生

```mysql
SELECT name FROM info
WHERE gpa <
(SELECT gpa FROM info ORDER BY gpa DESC LIMIT 1);
```

> 运行结果

```
+-------+
| name  |
+-------+
| Terry |
| Eric  |
| Henry |
+-------+
```

---

【代码】将info表中gpa大于3.5分的学生gpa增加0.1

```sql
UPDATE info SET gpa = gpa + 0.1
WHERE id IN
(SELECT id FROM info WHERE gpa > 3.5);

SELECT * FROM info;
```

> 运行结果

```
+----+-------+------+
| id | name  | gpa  |
+----+-------+------+
|  1 | Terry | 3.90 |
|  2 | Lily  | 4.30 |
|  3 | Eric  | 3.40 |
|  4 | Henry | 3.90 |
+----+-------+------+
```

---

MySQL中不支持在同一张表中查询又更新，因此需要改写SQL语句使其支持。

---

【代码】MySQL中实现将info表中gpa大于3.5分的学生gpa增加0.1

```mysql
UPDATE info SET gpa = gpa + 0.1
WHERE id IN (
SELECT a.id FROM
(SELECT id FROM info WHERE gpa > 3.5)
AS a
);

SELECT * FROM info;
```

> 运行结果

```
+----+-------+------+
| id | name  | gpa  |
+----+-------+------+
|  1 | Terry | 3.90 |
|  2 | Lily  | 4.30 |
|  3 | Eric  | 3.40 |
|  4 | Henry | 3.90 |
+----+-------+------+
```

---

<div style="page-break-after: always;"></div>

# 第19节 ANY & ALL

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS class_1;

CREATE TABLE class_1(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2)
);

INSERT INTO class_1 VALUES
(1, "Terry", 3.8),
(2, "Lily", 4.2),
(3, "Henry", 3.2);

DROP TABLE IF EXISTS class_2;

CREATE TABLE class_2(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2)
);

INSERT INTO class_2 VALUES
(1, "Eric", 3.4),
(2, "Alce", 4.2),
(3, "Shawn", 3.5);
```

---



**ANY & ALL**

如果子查询返回多条记录，那么主查询部分只能使用多值比较符（如IN），对于单值比较符（如`>`）则无法工作。

ANY和ALL主要解决子查询返回多条记录而主查询需要使用单值比较符的问题。

| 作用 | 说明                                 |
| :--: | ------------------------------------ |
| ANY  | 子查询结果集任一条记录满足比较符即可 |
| ALL  | 子查询结果集所有记录满足比较符才可   |

---

【代码】查询class_1中gpa低于class_2中任意一个的同学

```mysql
SELECT name, gpa FROM class_1
WHERE gpa < ANY
(SELECT gpa FROM class_2);
```

> 运行结果

```
+-------+------+
| name  | gpa  |
+-------+------+
| Terry | 3.80 |
| Henry | 3.20 |
+-------+------+
```

---

【代码】查询class_1中gpa低于class_2中所有人的同学

```mysql
SELECT name, gpa FROM class_1
WHERE gpa < ALL
(SELECT gpa FROM class_2);
```

> 运行结果

```
+-------+------+
| name  | gpa  |
+-------+------+
| Henry | 3.20 |
+-------+------+
```

---

<div style="page-break-after: always;"></div>

# 第20节 事务

**事务（Transaction）**

事务是数据库中的核心概念，指的是将数据库的一组操作作为一个整体，要么全部执行，要么都不执行。并不是每个数据库引擎都支持事务，如MySQL的`MyISAM`引擎就不支持事务。

事务具有四大特性，即`ACID`：

1. 原子性（atomicity）：每个事务都是一个整体，不可再拆分，事务中的操作要么全部执行成功，要么全部失败。
2. 一致性（consistency）：事务执行前后数据库的状态必须保持一致。如 A 转账给 B，转账后金额的总数是不变的。
3. 隔离性（isolation）：事务与事务之间互不影响，彼此隔离。
4. 持久性（durability）：事务一旦提交成功，对数据库的更改就是永久的，即使出现了其它情况，数据改变仍然存在。

事务的四大特性是事务最本质的特点，在这四个特性中，原子性是基础，隔离性是手段，一致性是约束条件，持久性是目的。

| 事务控制语句                      | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| START TRANSACTION或BEGIN          | 显式地开始一个事务                                           |
| COMMIT                            | 提交事务                                                     |
| SAVEPOINT                         | 创建保存点，一个事务可以有多个保存点，事务可以根据保存点进行回滚 |
| ROLLBACK或ROLLBACK TO [SAVEPOINT] | 回滚事务，默认回滚所有更改，如果加上保存点，则回滚到保存点   |
| RELEASE SAVEPOINT                 | 删除保存点，保存点被删除后，不可回滚                         |
| SET TRANSACTION                   | 设置事务的隔离级别                                           |



**并发异常**

在实际开发中，大量的并发会导致数据的竞争，从而引起一系列的并发问题。

SQL标准共定义了三种并发异常：

1. 脏读（dirty read）：读到了其它事务还未提交的数据。

    > A正在访问数据库，开启了一个事务，向info表中插入了一条记录：
    >
    > ```mysql
    > BEGIN;
    > INSERT INTO info VALUES (4, "Tina", 3.0);
    > ```
    >
    > A还未提交事务，但B此时却访问了数据库，并且查询了info表：
    >
    > ```mysql
    > SELECT * FROM info;
    > ```
    >
    > B获取到了如下信息：
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.00 |
    > +----+-------+------+
    > ```
    >
    > A明明还没有提交事务，但B却已经看到了A操作的结果。试想一下，如果此时A回滚了事务，那么对于B来说，他就看到了脏数据。

2. 不可重复读（nonrepeatable read）：两次读到了同一数据的不同结果。

    > A正在访问数据库，他查看了info表中id为4的学生：
    >
    > ```mysql
    > SELECT * FROM info WHERE id = 4;
    > ```
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.00 |
    > +----+-------+------+
    > ```
    >
    > 此时B也访问了数据库，他开启了一个事务，并修改了id为4的学生：
    >
    > ```mysql
    > BEGIN;
    > UPDATE info SET gpa = gpa + 0.1 WHERE id = 4;
    > ```
    >
    > A再次查看了一次id为4的学生：
    >
    > ```mysql
    > SELECT * FROM info WHERE id = 4;
    > ```
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.10 |
    > +----+-------+------+
    > ```
    >
    > A发现自己两次查询的数据不一样。

3. 幻读（phantom read）：读到了其它事务新增但未提交的数据，而且新增数据并未成功。

    > A正在访问数据库，开启了一个事务，并向info表中插入了一条记录：
    >
    > ```mysql
    > BEGIN;
    > INSERT INTO info VALUES (5, "Iris", 3.3);
    > ```
    >
    > 此时B查询了info表：
    >
    > ```mysql
    > SELECT * FROM info;
    > ```
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.10 |
    > |  5 | Iris  | 3.30 |
    > +----+-------+------+
    > ```
    >
    > B此时已经看到了新增的学生Iris了，但A后悔了，不想创建Iris了，于是A回滚了事务：
    >
    > ```mysql
    > ROLLBACK;
    > ```
    >
    > 但是B却看到了Iris，他一度以为自己出现了幻觉。



**隔离级别**

SQL事务的四种隔离机制主要是为了解决并发异常。下表隔离级别由上往下，级别依次提高，但消耗的性能也会依次提高。

| 隔离级别                   | 脏读 | 不可重复读 | 幻读 |
| -------------------------- | :--: | :--------: | :--: |
| 读未提交`READ UNCOMMITTED` | 允许 |    允许    | 允许 |
| 读已提交`READ COMMITTED`   | 禁止 |    允许    | 允许 |
| 可重复读`REPEATABLE READ`  | 禁止 |    禁止    | 允许 |
| 可串行化`SERIALIZABLE`     | 禁止 |    禁止    | 禁止 |

- 读未提交：允许读未提交数据，可能会发生脏读、不可重复读和幻读异常。

- 读已提交：只能读已经提交的数据，避免了脏读，但可能会出现不可重复读和幻读。

- 可重复读：能保证在一个事务中多次读取，数据一致，但可能会出现幻读。

- 可串行化：最高的隔离级别，串行的执行事务，可以避免三种异常，但性能耗损最高。

SQL Server和Oracle的默认隔离级别是读已提交，而MySQL的默认隔离级别是可重复读。

设置事务隔离级别语法如下：

```mysql
SET SESSION TRANSACTION ISOLATION LEVEL [level];
```

<div style="page-break-after: always;"></div>

# 第21节 INDEX

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2)
);

INSERT INTO info VALUES
(1, "Terry", 3.8),
(2, "Lily", 4.2),
(3, "Eric", 3.3),
(4, "Henry", 3.8);
```

---



**INDEX**

数据库在进行查询的时候，需要对整张表进行扫描，当数据表的数据量大的时候，这样扫描的效率是很低下的。为了提高数据检索能力，增强数据库查询性能，数据库引入了索引机制。

索引可以通过CREATE和DROP指令来创建和删除：

```mysql
CREATE [constraint] INDEX [index_name] ON [table_name]([col]);
DROP INDEX [index_name] ON [table_name];
```

索引的使用是智能的，数据库会自动找到对应的索引来加速查询。

---

【代码】为info表中的gpa字段新建索引，使用索引加速查询

```mysql
CREATE INDEX gpa_index ON info(gpa);
SELECT * FROM info WHERE gpa = 3.8;
```

> 运行结果

```
+----+-------+------+
| id | name  | gpa  |
+----+-------+------+
|  1 | Terry | 3.80 |
|  4 | Henry | 3.80 |
+----+-------+------+
```

---

<div style="page-break-after: always;"></div>

# 第22节 VIEW

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2)
);

INSERT INTO info VALUES
(1, "Terry", 3.8),
(2, "Lily", 4.2),
(3, "Eric", 3.3),
(4, "Henry", 3.8);
```

---



**VIEW**

在一些场景中，有些查询的结果集很大，且我们需要在多处复用到这些结果集。如果每次都去查询一次，会耗费大量的时间，SQL支持我们将这些数据集保存为视图，并且可以像操作表一样去操作这些视图。

视图`VIEW`是一个或多个表记录的集合，其结构和数据是建立在其它表的查询基础之上的。视图可以理解为表，它可以像表一样操作，但是视图不是真实存在，它只是一张虚表。

视图可以像数据表一样操作，且数据表的数据被更新后，也会同步更新到与之相关的视图中。

视图的数据来源于查询，视图的创建与删除语法如下：

```mysql
CREATE VIEW [view_name] 
AS
SELECT [col] FROM [table_name];

DROP VIEW [view_name];
```

---

【代码】查询info表的所有name和gpa字段，并以该结果新建一个视图

```mysql
CREATE VIEW student_shortcut_view 
AS
SELECT name, gpa FROM info;

SELECT * FROM student_shortcut_view;
```

> 运行结果

```
+-------+------+
| name  | gpa  |
+-------+------+
| Terry | 3.80 |
| Lily  | 4.20 |
| Eric  | 3.30 |
| Henry | 3.80 |
+-------+------+
```

---

<div style="page-break-after: always;"></div>

# 第23节 锁

**锁**

在一些并发场景中，会涉及到数据竞争问题。例如A、B二人同时要修改同一条记录，那么很大概率上，数据会起冲突，为了保证数据的安全性和正确性，SQL引入了锁。

从锁的粒度上可以将其分为如下四类：

| 名称 | 作用         | 说明                                                         |
| :--: | ------------ | ------------------------------------------------------------ |
| 库锁 | 锁定数据库   | 粒度最大，若非特殊情况（数据库备份），切勿使用               |
| 表锁 | 锁定数据表   | 粒度比较大，直接涉及一张表，若非特殊情况，切勿使用           |
| 页锁 | 锁定数据页   | SQL Server特有的锁，会锁定数据页，数据表中的数据是按页组织的 |
| 行锁 | 锁定一行记录 | 粒度最小，只锁定一条记录，推荐使用                           |

在粒度上，不同数据库，甚至不同引擎对锁的粒度支持都是不同的，如MySQL的`InnoDB`引擎支持行锁、表锁和库锁，而`MyISAM`引擎只支持到表锁。对于页锁，只有SQL Server支持，而不同数据库也有类似间隙锁的实现，它的功能与页锁差不多。

从数据库系统管理角度来看，可以把锁分为如下两类：

|     名称      | 描述                       |
| :-----------: | -------------------------- |
| 共享锁 / 读锁 | 其他人可以读取，但不能修改 |
| 排他锁 / 写锁 | 其他人不能读取，也不能修改 |

在管理上，锁根据数据是否共享来分类，对于读多写少的场景，共享锁几乎是并发的标配，而一旦涉及数据修改，锁就必须独占了。

上锁/解锁数据表语法如下：

```mysql
LOCK TABLE [table_name] [READ | WRITE];UNLOCK TABLE;
```

对一条记录加读锁语法如下：

```mysql
SELECT * FROM [table_name] WHERE [condition] LOCK IN SHARE MODE;
```

对一条记录加写锁语法如下：

```mysql
SELECT * FROM [table_name] WHERE [condition] FOR UPDATE;
```

<div style="page-break-after: always;"></div>

# 第24节 函数

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2),
    enrol_date timestamp
);

INSERT INTO info VALUES
(1, "Terry", 3.8, "2017-09-07 09:00:00"),
(2, "Lily", 4.2, "2018-09-09 20:30:15"),
(3, "Henry", 3.7, "2019-10-05 19:10:24"),
(4, "Eric", 3.2, "2016-09-12 15:57:48"),
(5, "Bob", 4.0, "2021-01-22 20:08:44");
```

---



**算术函数**

算术函数主要用于对数值类型的字段进行算术运算。

| 函数  | 作用                                                   |
| :---- | ------------------------------------------------------ |
| ABS   | 取绝对值                                               |
| MOD   | 取余数，接受两个参数，第一个为数值，第二个为除数       |
| ROUND | 四舍五入，接受两个参数，第一个为数值，第二个为小数位数 |

PostgreSQL不支持`ROUND()`。



**聚合函数**

聚合函数主要用于数据的统计和分析。

| 函数  | 作用                 |
| :---- | -------------------- |
| COUNT | 获取总行数（记录数） |
| MAX   | 获取最大值           |
| MIN   | 获取最小值           |
| SUM   | 获取总和             |
| AVG   | 获取平均值           |





**字符串函数**

字符串函数主要用于对字符类型的字段进行操作。

| 函数        | 作用                                                         |
| :---------- | ------------------------------------------------------------ |
| CONCAT      | 拼接多个字符串                                               |
| LENGTH      | 获取字符长度，一个中文汉字算3个字符，数字和字母算1个字符     |
| CHAR_LENGTH | 获取字符长度，中文汉字、数字和字母算1个字符                  |
| LOWER       | 将英文字符串全部转为小写                                     |
| UPPER       | 将英文字符串全部转为大写                                     |
| REPLACE     | 替换字符串，接受3个参数，分别是原字符串，被替代字符串，替代字符串 |
| SUBSTRING   | 截取字符串，接受3个参数，分别是原字符串，开始截取的位置，截取的长度 |



**日期函数**

日期函数主要用于对日期和时间类型的字段进行操作，常见的日期函数有：

| 函数              | 作用                 |
| ----------------- | -------------------- |
| CURRENT_DATE      | 获取当前日期         |
| CURRENT_TIME      | 获取当前时间         |
| CURRENT_TIMESTAMP | 获取当前时间戳       |
| DATE              | 提取时间戳的日期部分 |
| YEAR              | 提取时间戳的年份部分 |
| MONTH             | 提取时间戳的月份部分 |
| DAY               | 提取时间戳的天数部分 |
| HOUR              | 提取时间戳的小时部分 |
| MINUTE            | 提取时间戳的分钟部分 |
| SECOND            | 提取时间戳的秒部分   |

PostgreSQL不支持`CURRENT_XXX()`，获取当前时间戳可以使用`NOW()`。

---

【代码】获取info表统计信息

```mysql
SELECT
    COUNT(*),
    SUM(gpa),
    MAX(gpa),
    MIN(gpa),
    ROUND(AVG(gpa), 2)
FROM info;

SELECT
    CONCAT(name, "(", id, ")") AS student, 
    DATE(enrol_date)
FROM info;
```

> 运行结果

```
+---------+---------+---------+---------+-------------------+
|COUNT(*) |SUM(gpa) |MAX(gpa) |MIN(gpa) |ROUND(AVG(gpa), 2) |
+---------+---------+---------+---------+-------------------+
|       5 |   18.90 |    4.20 |    3.20 |              3.78 |
+---------+---------+---------+---------+-------------------+

+----------+------------------+
| student  | DATE(enrol_date) |
+----------+------------------+
| Terry(1) | 2017-09-07       |
| Lily(2)  | 2018-09-09       |
| Henry(3) | 2019-10-05       |
| Eric(4)  | 2016-09-12       |
| Bob(5)   | 2021-01-22       |
+----------+------------------+
```

---

