**并发异常**

在实际开发中，大量的并发会导致数据的竞争，从而引起一系列的并发问题。

SQL标准共定义了三种并发异常：

1. 脏读（dirty read）：读到了其它事务还未提交的数据。

    > A正在访问数据库，开启了一个事务，向info表中插入了一条记录：
    >
    > ```mysql
    > BEGIN;
    > INSERT INTO info VALUES (4, "Tina", 3.0);
    > ```
    >
    > A还未提交事务，但B此时却访问了数据库，并且查询了info表：
    >
    > ```mysql
    > SELECT * FROM info;
    > ```
    >
    > B获取到了如下信息：
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.00 |
    > +----+-------+------+
    > ```
    >
    > A明明还没有提交事务，但B却已经看到了A操作的结果。试想一下，如果此时A回滚了事务，那么对于B来说，他就看到了脏数据。

2. 不可重复读（nonrepeatable read）：两次读到了同一数据的不同结果。

    > A正在访问数据库，他查看了info表中id为4的学生：
    >
    > ```mysql
    > SELECT * FROM info WHERE id = 4;
    > ```
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.00 |
    > +----+-------+------+
    > ```
    >
    > 此时B也访问了数据库，他开启了一个事务，并修改了id为4的学生：
    >
    > ```mysql
    > BEGIN;
    > UPDATE info SET gpa = gpa + 0.1 WHERE id = 4;
    > ```
    >
    > A再次查看了一次id为4的学生：
    >
    > ```mysql
    > SELECT * FROM info WHERE id = 4;
    > ```
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.10 |
    > +----+-------+------+
    > ```
    >
    > A发现自己两次查询的数据不一样。

3. 幻读（phantom read）：读到了其它事务新增但未提交的数据，而且新增数据并未成功。

    > A正在访问数据库，开启了一个事务，并向info表中插入了一条记录：
    >
    > ```mysql
    > BEGIN;
    > INSERT INTO info VALUES (5, "Iris", 3.3);
    > ```
    >
    > 此时B查询了info表：
    >
    > ```mysql
    > SELECT * FROM info;
    > ```
    >
    > ```
    > +----+-------+------+
    > | id | name  | gpa  |
    > +----+-------+------+
    > |  4 | Tina  | 3.10 |
    > |  5 | Iris  | 3.30 |
    > +----+-------+------+
    > ```
    >
    > B此时已经看到了新增的学生Iris了，但A后悔了，不想创建Iris了，于是A回滚了事务：
    >
    > ```mysql
    > ROLLBACK;
    > ```
    >
    > 但是B却看到了Iris，他一度以为自己出现了幻觉。



**隔离级别**

SQL事务的四种隔离机制主要是为了解决并发异常。下表隔离级别由上往下，级别依次提高，但消耗的性能也会依次提高。

| 隔离级别                   | 脏读 | 不可重复读 | 幻读 |
| -------------------------- | :--: | :--------: | :--: |
| 读未提交`READ UNCOMMITTED` | 允许 |    允许    | 允许 |
| 读已提交`READ COMMITTED`   | 禁止 |    允许    | 允许 |
| 可重复读`REPEATABLE READ`  | 禁止 |    禁止    | 允许 |
| 可串行化`SERIALIZABLE`     | 禁止 |    禁止    | 禁止 |

- 读未提交：允许读未提交数据，可能会发生脏读、不可重复读和幻读异常。

- 读已提交：只能读已经提交的数据，避免了脏读，但可能会出现不可重复读和幻读。

- 可重复读：能保证在一个事务中多次读取，数据一致，但可能会出现幻读。

- 可串行化：最高的隔离级别，串行的执行事务，可以避免三种异常，但性能耗损最高。

SQL Server和Oracle的默认隔离级别是读已提交，而MySQL的默认隔离级别是可重复读。

设置事务隔离级别语法如下：

```mysql
SET SESSION TRANSACTION ISOLATION LEVEL [level];
```

<div style="page-break-after: always;"></div>

# 第21节 INDEX

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2)
);

INSERT INTO info VALUES
(1, "Terry", 3.8),
(2, "Lily", 4.2),
(3, "Eric", 3.3),
(4, "Henry", 3.8);
```

---



**INDEX**

数据库在进行查询的时候，需要对整张表进行扫描，当数据表的数据量大的时候，这样扫描的效率是很低下的。为了提高数据检索能力，增强数据库查询性能，数据库引入了索引机制。

索引可以通过CREATE和DROP指令来创建和删除：

```mysql
CREATE [constraint] INDEX [index_name] ON [table_name]([col]);
DROP INDEX [index_name] ON [table_name];
```

索引的使用是智能的，数据库会自动找到对应的索引来加速查询。

---

【代码】为info表中的gpa字段新建索引，使用索引加速查询

```mysql
CREATE INDEX gpa_index ON info(gpa);
SELECT * FROM info WHERE gpa = 3.8;
```

> 运行结果

```
+----+-------+------+
| id | name  | gpa  |
+----+-------+------+
|  1 | Terry | 3.80 |
|  4 | Henry | 3.80 |
+----+-------+------+
```

---

<div style="page-break-after: always;"></div>

# 第22节 VIEW

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2)
);

INSERT INTO info VALUES
(1, "Terry", 3.8),
(2, "Lily", 4.2),
(3, "Eric", 3.3),
(4, "Henry", 3.8);
```

---



**VIEW**

在一些场景中，有些查询的结果集很大，且我们需要在多处复用到这些结果集。如果每次都去查询一次，会耗费大量的时间，SQL支持我们将这些数据集保存为视图，并且可以像操作表一样去操作这些视图。

视图`VIEW`是一个或多个表记录的集合，其结构和数据是建立在其它表的查询基础之上的。视图可以理解为表，它可以像表一样操作，但是视图不是真实存在，它只是一张虚表。

视图可以像数据表一样操作，且数据表的数据被更新后，也会同步更新到与之相关的视图中。

视图的数据来源于查询，视图的创建与删除语法如下：

```mysql
CREATE VIEW [view_name] 
AS
SELECT [col] FROM [table_name];

DROP VIEW [view_name];
```

---

【代码】查询info表的所有name和gpa字段，并以该结果新建一个视图

```mysql
CREATE VIEW student_shortcut_view 
AS
SELECT name, gpa FROM info;

SELECT * FROM student_shortcut_view;
```

> 运行结果

```
+-------+------+
| name  | gpa  |
+-------+------+
| Terry | 3.80 |
| Lily  | 4.20 |
| Eric  | 3.30 |
| Henry | 3.80 |
+-------+------+
```

---

<div style="page-break-after: always;"></div>

# 第23节 锁

**锁**

在一些并发场景中，会涉及到数据竞争问题。例如A、B二人同时要修改同一条记录，那么很大概率上，数据会起冲突，为了保证数据的安全性和正确性，SQL引入了锁。

从锁的粒度上可以将其分为如下四类：

| 名称 | 作用         | 说明                                                         |
| :--: | ------------ | ------------------------------------------------------------ |
| 库锁 | 锁定数据库   | 粒度最大，若非特殊情况（数据库备份），切勿使用               |
| 表锁 | 锁定数据表   | 粒度比较大，直接涉及一张表，若非特殊情况，切勿使用           |
| 页锁 | 锁定数据页   | SQL Server特有的锁，会锁定数据页，数据表中的数据是按页组织的 |
| 行锁 | 锁定一行记录 | 粒度最小，只锁定一条记录，推荐使用                           |

在粒度上，不同数据库，甚至不同引擎对锁的粒度支持都是不同的，如MySQL的`InnoDB`引擎支持行锁、表锁和库锁，而`MyISAM`引擎只支持到表锁。对于页锁，只有SQL Server支持，而不同数据库也有类似间隙锁的实现，它的功能与页锁差不多。

从数据库系统管理角度来看，可以把锁分为如下两类：

|     名称      | 描述                       |
| :-----------: | -------------------------- |
| 共享锁 / 读锁 | 其他人可以读取，但不能修改 |
| 排他锁 / 写锁 | 其他人不能读取，也不能修改 |

在管理上，锁根据数据是否共享来分类，对于读多写少的场景，共享锁几乎是并发的标配，而一旦涉及数据修改，锁就必须独占了。

上锁/解锁数据表语法如下：

```mysql
LOCK TABLE [table_name] [READ | WRITE];UNLOCK TABLE;
```

对一条记录加读锁语法如下：

```mysql
SELECT * FROM [table_name] WHERE [condition] LOCK IN SHARE MODE;
```

对一条记录加写锁语法如下：

```mysql
SELECT * FROM [table_name] WHERE [condition] FOR UPDATE;
```

<div style="page-break-after: always;"></div>

# 第24节 函数

**初始数据**

---

【代码】初始数据

```mysql
DROP TABLE IF EXISTS info;

CREATE TABLE info(
    id int unsigned PRIMARY KEY AUTO_INCREMENT,
    name varchar(20),
    gpa double(5, 2),
    enrol_date timestamp
);

INSERT INTO info VALUES
(1, "Terry", 3.8, "2017-09-07 09:00:00"),
(2, "Lily", 4.2, "2018-09-09 20:30:15"),
(3, "Henry", 3.7, "2019-10-05 19:10:24"),
(4, "Eric", 3.2, "2016-09-12 15:57:48"),
(5, "Bob", 4.0, "2021-01-22 20:08:44");
```

---



**算术函数**

算术函数主要用于对数值类型的字段进行算术运算。

| 函数  | 作用                                                   |
| :---- | ------------------------------------------------------ |
| ABS   | 取绝对值                                               |
| MOD   | 取余数，接受两个参数，第一个为数值，第二个为除数       |
| ROUND | 四舍五入，接受两个参数，第一个为数值，第二个为小数位数 |

PostgreSQL不支持`ROUND()`。



**聚合函数**

聚合函数主要用于数据的统计和分析。

| 函数  | 作用                 |
| :---- | -------------------- |
| COUNT | 获取总行数（记录数） |
| MAX   | 获取最大值           |
| MIN   | 获取最小值           |
| SUM   | 获取总和             |
| AVG   | 获取平均值           |





**字符串函数**

字符串函数主要用于对字符类型的字段进行操作。

| 函数        | 作用                                                         |
| :---------- | ------------------------------------------------------------ |
| CONCAT      | 拼接多个字符串                                               |
| LENGTH      | 获取字符长度，一个中文汉字算3个字符，数字和字母算1个字符     |
| CHAR_LENGTH | 获取字符长度，中文汉字、数字和字母算1个字符                  |
| LOWER       | 将英文字符串全部转为小写                                     |
| UPPER       | 将英文字符串全部转为大写                                     |
| REPLACE     | 替换字符串，接受3个参数，分别是原字符串，被替代字符串，替代字符串 |
| SUBSTRING   | 截取字符串，接受3个参数，分别是原字符串，开始截取的位置，截取的长度 |



**日期函数**

日期函数主要用于对日期和时间类型的字段进行操作，常见的日期函数有：

| 函数              | 作用                 |
| ----------------- | -------------------- |
| CURRENT_DATE      | 获取当前日期         |
| CURRENT_TIME      | 获取当前时间         |
| CURRENT_TIMESTAMP | 获取当前时间戳       |
| DATE              | 提取时间戳的日期部分 |
| YEAR              | 提取时间戳的年份部分 |
| MONTH             | 提取时间戳的月份部分 |
| DAY               | 提取时间戳的天数部分 |
| HOUR              | 提取时间戳的小时部分 |
| MINUTE            | 提取时间戳的分钟部分 |
| SECOND            | 提取时间戳的秒部分   |

PostgreSQL不支持`CURRENT_XXX()`，获取当前时间戳可以使用`NOW()`。

---

【代码】获取info表统计信息

```mysql
SELECT
    COUNT(*),
    SUM(gpa),
    MAX(gpa),
    MIN(gpa),
    ROUND(AVG(gpa), 2)
FROM info;

SELECT
    CONCAT(name, "(", id, ")") AS student, 
    DATE(enrol_date)
FROM info;
```

> 运行结果

```
+---------+---------+---------+---------+-------------------+
|COUNT(*) |SUM(gpa) |MAX(gpa) |MIN(gpa) |ROUND(AVG(gpa), 2) |
+---------+---------+---------+---------+-------------------+
|       5 |   18.90 |    4.20 |    3.20 |              3.78 |
+---------+---------+---------+---------+-------------------+

+----------+------------------+
| student  | DATE(enrol_date) |
+----------+------------------+
| Terry(1) | 2017-09-07       |
| Lily(2)  | 2018-09-09       |
| Henry(3) | 2019-10-05       |
| Eric(4)  | 2016-09-12       |
| Bob(5)   | 2021-01-22       |
+----------+------------------+
```

---

